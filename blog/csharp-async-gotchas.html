<!DOCTYPE html>
<!--[if IE 8]> 				 <html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->

<head>
  <meta charset="utf-8">
  <title>Async in C# and F#: Asynchronous gotchas in C#</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="This article is inspired by an MVP summit talk about common pitfalls in the C# asynchronous programming model. I look at a number of easy to make mistakes when writing asynchronous code in C# and demonstrate that most of them would not easily happen when using F#. ">
  <meta name="author" content="Tomas Petricek">

  <!-- Reference Foundation -->
  <link rel="stylesheet" href="file://C:\Tomas\Projects\WebSites\TomaspNet.New\output\css/foundation.css">
  <script src="file://C:\Tomas\Projects\WebSites\TomaspNet.New\output\js/vendor/custom.modernizr.js"></script>

  <!-- Reference custom CSS and tooltips -->
  <link type="text/css" rel="stylesheet" href="file://C:\Tomas\Projects\WebSites\TomaspNet.New\output\custom/style.css" />
  <script type="text/javascript" src="file://C:\Tomas\Projects\WebSites\TomaspNet.New\output\custom/tooltips.js"></script>
  <link type="text/css" rel="stylesheet" href="file://C:\Tomas\Projects\WebSites\TomaspNet.New\output\custom/tooltips.css" />
</head>
<body>

   <header id="top-header">
    <div class="row">
      <div class="twelve columns">
        <h1>Tomas Petricek's blog</h1>
        <p>Writing about practical F# coding and programming language research</p>
      </div>
    </div>
  </header>

  <header class="top-bar-header">
    <div class="contain-to-grid sticky">
    <nav class="top-bar">

    <ul class="title-area">
      <!-- Title Area -->
      <li class="name"><h1><a href="#"></a></h1></li>
      <!-- Remove the class "menu-icon" to get rid of menu icon. Take out "Menu" to just have icon alone -->
      <li class="toggle-topbar menu-icon"><a href="#"><span>Menu</span></a></li>
    </ul>

    <section class="top-bar-section">
      <!-- Right Nav Section -->
      <ul class="right">
        <li><a href="#">Blog</a></li>
        <li><a href="#">Trainings</a></li>
        <li><a href="#">Books</a></li>
        <li><a href="#">Talks</a></li>
        <li><a href="#">Research & Teaching</a></li>
      </ul>
    </section>

    </nav></div>
  </header>
  
  <content>
    

<div class="row">
	<div class="large-8 columns main-content">
    <content>
    
<h1>Async in C# and F#: Asynchronous gotchas in C#</h1>

<p>Back in February, I attended the annual MVP summit - an <a href="http://www.2013mvpsummit.com/about">event organized by Microsoft
for MVPs</a>. I used that opportunity to also visit
Boston and New York and do two F# talks and to record a <a href="http://channel9.msdn.com/posts/Tomas-Petricek-How-F-Learned-to-Stop-Worrying-and-Love-the-Data" title="Tomas Petricek (Channel 9): How F# Learned to Stop Worrying and Love the Data">Channel9 lecutre about type
providers</a>.
Despite all the <em>other activities</em> (often involving pubs, other F# people and long 
sleeping in the mornings), I also managed to come to some talks!</p>

<div style="margin-left:auto;margin-right:auto;width:379px;margin-top:10px;margin-bottom:20px;">
<img src="http://tomasp.net/articles/csharp-async-gotchas/async-clinic.png" style="width:379px;" />
</div>

<p>One (non-NDA) talk was the <a href="http://blogs.msdn.com/b/pfxteam/archive/2013/02/20/mvp-summit-presentation-on-async.aspx" title="Lucian Wischik, Stephen Toub: Async Clinic">Async Clinic</a> talk about the new <code>async</code> and <code>await</code> keywords 
in C# 5.0. Lucian and Stephen talked about common problems that C# developers face when 
writing asynchronous programs. In this blog post, I'll look at some of the problems from 
the F# perspective. The talk was quite lively, and someone recorded the reaction of the 
F# part of the audience as follows:</p>

<div style="margin-left:auto;margin-right:auto;width:379px;margin-top:10px;margin-bottom:20px;">
<a href="https://twitter.com/josefajardo/status/303998917027192832"><img src="http://tomasp.net/articles/csharp-async-gotchas/tweet.png" style="border-style:none" /></a>
</div>

<p>Why is that? It turns out that many of the common errors are not possible (or much less
likely) when using the F# asynchronous model (which has been around <a href="http://blogs.msdn.com/b/dsyme/archive/2007/07/27/f-1-9-2-7-released.aspx">since F# 1.9.2.7, which
was released in 2007</a>
and have been shipped with Visual Studio 2008).</p>

<h2>Gotcha #1: Async does not run asynchronously</h2>

<p>Let's go straight to the first tricky aspect of the C# asynchronous programming model. Take 
a look at the following example and figure out in what order will the strings be printed 
(I could not find the exact code shown at the talk, but I remember Lucian showing something
similar):</p>

<pre><code>async Task WorkThenWait() {
  Thread.Sleep(1000);
  Console.WriteLine("work");
  await Task.Delay(1000);
}

void Demo() {
  var child = WorkThenWait();
  Console.WriteLine("started");
  child.Wait();
  Console.WriteLine("completed");
}
</code></pre>

<p>If you guessed that it prints "started", "work" and "completed" then you're wrong. The code
prints "work", "started" and "completed", try it! What the author intended was to start 
the work (by calling <code>WorkThenWait</code>) and then await for the task later. The problem is that
<code>WorkThenWait</code> starts by doing some heavy computations (here, <code>Thread.Sleep</code>) and only after
that uses <code>await</code>.</p>

<p>In C#, the first part of the code in <code>async</code> method is executed synchronously (on the 
thread of the caller). You could fix that, for example, by adding <code>await Task.Yield()</code> at the 
beginning.</p>

<h3>Corresponding F# code</h3>

<p>This is not a problem in F#. When writing async code in F#, the entire code inside 
<code>async { ... }</code> block is all delayed and only started later (when you explicitly start it).
The above C# code corresponds to the following F#:</p>
<pre class="fssnip">
<span class="l"> 1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="i">workThenWait</span>() <span class="o">=</span> 
<span class="l"> 2: </span>  <span onmouseout="hideTip(event, 'fs2', 2)" onmouseover="showTip(event, 'fs2', 2)" class="i">Thread</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs3', 3)" onmouseover="showTip(event, 'fs3', 3)" class="i">Sleep</span>(<span class="n">1000</span>)
<span class="l"> 3: </span>  <span onmouseout="hideTip(event, 'fs4', 4)" onmouseover="showTip(event, 'fs4', 4)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">work</span><span class="s"> </span><span class="s">done</span><span class="s">&quot;</span>
<span class="l"> 4: </span>  <span onmouseout="hideTip(event, 'fs5', 5)" onmouseover="showTip(event, 'fs5', 5)" class="i">async</span> { <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs6', 6)" onmouseover="showTip(event, 'fs6', 6)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs7', 7)" onmouseover="showTip(event, 'fs7', 7)" class="i">Sleep</span>(<span class="n">1000</span>) }
<span class="l"> 5: </span>
<span class="l"> 6: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fs8', 8)" onmouseover="showTip(event, 'fs8', 8)" class="i">demo</span>() <span class="o">=</span> 
<span class="l"> 7: </span>  <span class="k">let</span> <span onmouseout="hideTip(event, 'fs9', 9)" onmouseover="showTip(event, 'fs9', 9)" class="i">work</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs1', 10)" onmouseover="showTip(event, 'fs1', 10)" class="i">workThenWait</span>() <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs6', 11)" onmouseover="showTip(event, 'fs6', 11)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs10', 12)" onmouseover="showTip(event, 'fs10', 12)" class="i">StartAsTask</span>
<span class="l"> 8: </span>  <span onmouseout="hideTip(event, 'fs4', 13)" onmouseover="showTip(event, 'fs4', 13)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">started</span><span class="s">&quot;</span>
<span class="l"> 9: </span>  <span onmouseout="hideTip(event, 'fs9', 14)" onmouseover="showTip(event, 'fs9', 14)" class="i">work</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs11', 15)" onmouseover="showTip(event, 'fs11', 15)" class="i">Wait</span>()
<span class="l">10: </span>  <span onmouseout="hideTip(event, 'fs4', 16)" onmouseover="showTip(event, 'fs4', 16)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">completed</span><span class="s">&quot;</span></pre>
<p>It is quite clear that the <code>workThenWait</code> function is not doing the work (<code>Thread.Sleep</code>) 
as part of the asynchronous computation and that it will be executed when the function
is called (and not when the async workflow is started).
The usual F# pattern is to wrap the entire function body in <code>async</code>. In F#, you
would write the following, which works as expected:</p>
<pre class="fssnip">
<span class="l">1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fs1', 17)" onmouseover="showTip(event, 'fs1', 17)" class="i">workThenWait</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'fs5', 18)" onmouseover="showTip(event, 'fs5', 18)" class="i">async</span> { 
<span class="l">2: </span>  <span onmouseout="hideTip(event, 'fs2', 19)" onmouseover="showTip(event, 'fs2', 19)" class="i">Thread</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs3', 20)" onmouseover="showTip(event, 'fs3', 20)" class="i">Sleep</span>(<span class="n">1000</span>)
<span class="l">3: </span>  <span onmouseout="hideTip(event, 'fs4', 21)" onmouseover="showTip(event, 'fs4', 21)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">work</span><span class="s"> </span><span class="s">done</span><span class="s">&quot;</span>
<span class="l">4: </span>  <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs6', 22)" onmouseover="showTip(event, 'fs6', 22)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs7', 23)" onmouseover="showTip(event, 'fs7', 23)" class="i">Sleep</span>(<span class="n">1000</span>) }</pre>
<h2>Gotcha #2: Ignoring results</h2>

<p>Here is another gotcha in the C# asynchronous programming model (this one is taken directly
from Lucian's slides). Guess what happens when you run the following asynchronous method:</p>

<pre><code>async Task Handler() {
  Console.WriteLine("Before");
  Task.Delay(1000);
  Console.WriteLine("After");
}
</code></pre>

<p>Were you expecting that it prints "Before", waits 1 second and then prints "After"? Wrong!
It prints both messages immediately without any waiting in between. The problem is that
<code>Task.Delay</code> <em>returns</em> a <code>Task</code> and we forgot to await until it completes using <code>await</code>.</p>

<h3>Corresponding F# code</h3>

<p>Again, you would probably not hit this issue in F#. You can surely write code that calls
<code>Async.Sleep</code> and ignores the returned <code>Async&lt;unit&gt;</code>:</p>
<pre class="fssnip">
<span class="l">1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fs12', 24)" onmouseover="showTip(event, 'fs12', 24)" class="i">handler</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'fs5', 25)" onmouseover="showTip(event, 'fs5', 25)" class="i">async</span> {
<span class="l">2: </span>  <span onmouseout="hideTip(event, 'fs4', 26)" onmouseover="showTip(event, 'fs4', 26)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">Before</span><span class="s">&quot;</span>
<span class="l">3: </span>  <span onmouseout="hideTip(event, 'fs6', 27)" onmouseover="showTip(event, 'fs6', 27)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs7', 28)" onmouseover="showTip(event, 'fs7', 28)" class="i">Sleep</span>(<span class="n">1000</span>)
<span class="l">4: </span>  <span onmouseout="hideTip(event, 'fs4', 29)" onmouseover="showTip(event, 'fs4', 29)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">After</span><span class="s">&quot;</span> }</pre>
<p>If you paste the code in Visual Studio, MonoDevelop or Try F#, you get an immediate 
feedback with a warning saying that:</p>

<blockquote>
  <p>warning FS0020: This expression should have type <code>unit</code>, but has type 
<code>Async&lt;unit&gt;</code>. Use <code>ignore</code> to discard the result of the expression, or 
<code>let</code> to bind the result to a name.</p>
</blockquote>

<p>You can still compile the code and run it, but if you read the warning, you'll see
that the expression returns <code>Async&lt;unit&gt;</code> and you need to await it using <code>do!</code>:</p>
<pre class="fssnip">
<span class="l">1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fs12', 30)" onmouseover="showTip(event, 'fs12', 30)" class="i">handler</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'fs5', 31)" onmouseover="showTip(event, 'fs5', 31)" class="i">async</span> {
<span class="l">2: </span>  <span onmouseout="hideTip(event, 'fs4', 32)" onmouseover="showTip(event, 'fs4', 32)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">Before</span><span class="s">&quot;</span>
<span class="l">3: </span>  <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs6', 33)" onmouseover="showTip(event, 'fs6', 33)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs7', 34)" onmouseover="showTip(event, 'fs7', 34)" class="i">Sleep</span>(<span class="n">1000</span>)
<span class="l">4: </span>  <span onmouseout="hideTip(event, 'fs4', 35)" onmouseover="showTip(event, 'fs4', 35)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">After</span><span class="s">&quot;</span> }</pre>
<h2>Gotcha #3: Async void methods</h2>

<p>Quite a lot of time in the talk was dedicated to <em>async void</em> methods. If you write
<code>async void Foo() { ... }</code>, then the C# compiler generates a method that returns
<code>void</code>. Under the cover, it creates and starts a task. This means that you have no way
of telling when the work has actually happened.</p>

<p>Here is a recommendation on the <em>async void</em> pattern from the talk:</p>

<div style="margin-left:auto;margin-right:auto;width:379px;margin-top:10px;margin-bottom:20px;">
<img src="http://tomasp.net/articles/csharp-async-gotchas/async-void.png" style="width:379px;" />
</div>

<p>To be fair - async void methods <em>can</em> be useful when you're writing an event handler.
Event handlers should return <code>void</code> and they often start some work that continues in 
background. But I do not think this is really useful in the world of MVVM - but it 
surely makes nice demos at conference talks.</p>

<p>Let me demonstrate the problem using a snippet from <a href="http://msdn.microsoft.com/en-us/magazine/jj991977.aspx" title="Stephen Cleary: Best Practices in Asynchronous Programming">MSDN Magazine article</a>
on asynchronous programming in C#:</p>

<pre><code>async void ThrowExceptionAsync() {
  throw new InvalidOperationException();
}

public void CallThrowExceptionAsync() {
  try {
    ThrowExceptionAsync();
  } catch (Exception) {
    Console.WriteLine("Failed");
  }
}
</code></pre>

<p>Do you think that the code prints "Failed"? I suppose you already understood the style
of this blog post... Indeed, the exception is not handled because <code>ThrowExceptionAsync</code>
starts the work and returns immediately (and the exception happens somewhere on a background
thread).</p>

<h3>Corresponding F# code</h3>

<p>So, if you should not be using a programming language feature, then it is probably 
better not to include the feature in the first place. F# does not let you write
<em>async void</em> functions - when you wrap function body in the <code>async { ... }</code> block,
its return type will be <code>Async&lt;T&gt;</code>. If you used type annotations and demanded <code>unit</code>, 
you would get a type mismatch.</p>

<p>You can still write code that corresponds to the above C# using <code>Async.Start</code>:</p>
<pre class="fssnip">
<span class="l">1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fs13', 36)" onmouseover="showTip(event, 'fs13', 36)" class="i">throwExceptionAsync</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'fs5', 37)" onmouseover="showTip(event, 'fs5', 37)" class="i">async</span> {
<span class="l">2: </span>  <span onmouseout="hideTip(event, 'fs14', 38)" onmouseover="showTip(event, 'fs14', 38)" class="i">raise</span> <span class="o">&lt;|</span> <span class="k">new</span> <span onmouseout="hideTip(event, 'fs15', 39)" onmouseover="showTip(event, 'fs15', 39)" class="i">InvalidOperationException</span>() }
<span class="l">3: </span>
<span class="l">4: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fs16', 40)" onmouseover="showTip(event, 'fs16', 40)" class="i">callThrowExceptionAsync</span>() <span class="o">=</span> 
<span class="l">5: </span>  <span class="k">try</span>
<span class="l">6: </span>    <span onmouseout="hideTip(event, 'fs13', 41)" onmouseover="showTip(event, 'fs13', 41)" class="i">throwExceptionAsync</span>()
<span class="l">7: </span>    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs6', 42)" onmouseover="showTip(event, 'fs6', 42)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs17', 43)" onmouseover="showTip(event, 'fs17', 43)" class="i">Start</span>
<span class="l">8: </span>  <span class="k">with</span> <span onmouseout="hideTip(event, 'fs18', 44)" onmouseover="showTip(event, 'fs18', 44)" class="i">e</span> <span class="k">-&gt;</span>
<span class="l">9: </span>    <span onmouseout="hideTip(event, 'fs4', 45)" onmouseover="showTip(event, 'fs4', 45)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">Failed</span><span class="s">&quot;</span></pre>
<p>This will also not handle the exception. But it is more obvious what is going on because
we had to write <code>Async.Start</code> explicitly. If we did not write it, we would get a 
warning saying that the function returns <code>Async&lt;void&gt;</code> and we are ignoring the result
(the same as in the earlier section "Ignoring results").</p>

<h2>Gotcha #4: Async void lambda functions</h2>

<p>Even trickier case is when you pass asynchronous lambda function to some method as a 
delegate. In this case, the C# compiler infers the type of method from the delegate type.
If you use the <code>Action</code> delegate (or similar), then the compiler produces async void
function (which starts the work and returns <code>void</code>). If you use the <code>Func&lt;Task&gt;</code> delegate,
the compiler generates a function that returns <code>Task</code>.</p>

<p>Here is a sample from Lucian's slides. Does the following (perfectly valid) code finish 
in 1 second (after all the tasks finish sleeping), or does it finish immediately?</p>

<pre><code>Parallel.For(0, 10, async i =&gt; {
  await Task.Delay(1000);
});
</code></pre>

<p>You cannot know that, unless you know that <code>For</code> only has overloads that take <code>Action</code>
delegates - and thus the lambda function will always be compiled as async void. This
also means that adding such (maybe useful?) overload would be a breaking change.</p>

<h3>Corresponding F# code</h3>

<p>The F# language does not have special "async lambda functions", but you can surely
write a lambda function that returns asynchronous computation. The return type of such
function will be <code>Async&lt;T&gt;</code> and so it cannot be passed as an argument to methods that
expect void-returning delegate. The following F# code does not compile:</p>
<pre class="fssnip">
<span class="l">1: </span><span onmouseout="hideTip(event, 'fs19', 46)" onmouseover="showTip(event, 'fs19', 46)" class="i">Parallel</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs20', 47)" onmouseover="showTip(event, 'fs20', 47)" class="i">For</span>(<span class="n">0</span>, <span class="n">10</span>, <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs21', 48)" onmouseover="showTip(event, 'fs21', 48)" class="i">i</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs5', 49)" onmouseover="showTip(event, 'fs5', 49)" class="i">async</span> {
<span class="l">2: </span>  <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs6', 50)" onmouseover="showTip(event, 'fs6', 50)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs7', 51)" onmouseover="showTip(event, 'fs7', 51)" class="i">Sleep</span>(<span class="n">1000</span>) 
<span class="l">3: </span>})</pre>
<p>The error message simply says that a function type <code>int -&gt; Async&lt;unit&gt;</code> is not 
compatible with the <code>Action&lt;int&gt;</code> delegate (which would be <code>int -&gt; unit</code> in F#):</p>

<blockquote>
  <p>error FS0041: No overloads match for method <code>For</code>. The available overloads 
are shown below (or in the Error List window).</p>
</blockquote>

<p>To get the same behaviour as the above C# code, we need to explicitly start the
work. If you want to start asynchronous workflow in the background, then you can
easily do that using <code>Async.Start</code> (which takes a unit-returning asynchronous
computation, schedules it and returns <code>unit</code>):</p>
<pre class="fssnip">
<span class="l">1: </span><span onmouseout="hideTip(event, 'fs19', 52)" onmouseover="showTip(event, 'fs19', 52)" class="i">Parallel</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs20', 53)" onmouseover="showTip(event, 'fs20', 53)" class="i">For</span>(<span class="n">0</span>, <span class="n">10</span>, <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs22', 54)" onmouseover="showTip(event, 'fs22', 54)" class="i">i</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs6', 55)" onmouseover="showTip(event, 'fs6', 55)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs17', 56)" onmouseover="showTip(event, 'fs17', 56)" class="i">Start</span>(<span onmouseout="hideTip(event, 'fs5', 57)" onmouseover="showTip(event, 'fs5', 57)" class="i">async</span> {
<span class="l">2: </span>  <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs6', 58)" onmouseover="showTip(event, 'fs6', 58)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs7', 59)" onmouseover="showTip(event, 'fs7', 59)" class="i">Sleep</span>(<span class="n">1000</span>) 
<span class="l">3: </span>}))</pre>
<p>You can certainly write this, but it is quite easy to see what is going on. 
It is also not difficult to see that we are wasting resources, because the point
of <code>Parallel.For</code> is that it runs <em>CPU-intensive</em> computations (which are typically
synchronous functions) in parallel.</p>

<h2>Gotcha #5: Nesting of tasks</h2>

<p>I think that Lucian included the next one just to test the mental-compilation
skills of the people in the audience, but here it is. The question is, does the
following code wait 1 second between the two prints?</p>

<pre><code>Console.WriteLine("Before");
await Task.Factory.StartNew(
  async () =&gt; { await Task.Delay(1000); });
Console.WriteLine("After");
</code></pre>

<p>Again, quite unexpectedly, this does not actually wait between the two writes.
How is that possible? The <code>StartNew</code> method takes a delegate and returns a <code>Task&lt;T&gt;</code>
where <code>T</code> is the type returned by the delegate. In the above case, the delegate
returns <code>Task</code>, so we get <code>Task&lt;Task&gt;</code> as the result. Using <code>await</code> waits only
for the completion of the outer task (which immediately returns the inner task)
and the inner task is then ignored.</p>

<p>In C#, you can fix this by using <code>Task.Run</code> instead of <code>StartNew</code> (or by dropping
the <code>async</code> and <code>await</code> in the lambda function).</p>

<p>Can we write something similar in F#? We can create a task that will return
<code>Async&lt;unit&gt;</code> using <code>Task.Factory.StartNew</code> and lambda function that returns an
async block. To await the task, we will need to convert it to asynchronous workflo
using <code>Async.AwaitTask</code>. This means we will get <code>Async&lt;Async&lt;unit&gt;&gt;</code>:</p>
<pre class="fssnip">
<span class="l">1: </span><span onmouseout="hideTip(event, 'fs5', 60)" onmouseover="showTip(event, 'fs5', 60)" class="i">async</span> {
<span class="l">2: </span>  <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs23', 61)" onmouseover="showTip(event, 'fs23', 61)" class="i">Task</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs24', 62)" onmouseover="showTip(event, 'fs24', 62)" class="i">Factory</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs25', 63)" onmouseover="showTip(event, 'fs25', 63)" class="i">StartNew</span>(<span class="k">fun</span> () <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs5', 64)" onmouseover="showTip(event, 'fs5', 64)" class="i">async</span> { 
<span class="l">3: </span>    <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs6', 65)" onmouseover="showTip(event, 'fs6', 65)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs7', 66)" onmouseover="showTip(event, 'fs7', 66)" class="i">Sleep</span>(<span class="n">1000</span>) }) <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs6', 67)" onmouseover="showTip(event, 'fs6', 67)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs26', 68)" onmouseover="showTip(event, 'fs26', 68)" class="i">AwaitTask</span> }</pre>
<p>Again, this code does not compile. The problem is that the <code>do!</code> keyword requires
<code>Async&lt;unit&gt;</code> on the right-hand side, but it actually gets <code>Async&lt;Async&lt;unit&gt;&gt;</code>. In
other words, we cannot simply ignore the result. We need to explicitly do something
with it (we could use <code>Async.Ignore</code> to replicate the C# behaviour). The error 
message might not be as clear as the earlier messages, but you can get the idea:</p>

<blockquote>
  <p>error FS0001: This expression was expected to have type <code>Async&lt;unit&gt;</code> 
but here has type <code>unit</code></p>
</blockquote>

<h2>Gotcha #6: Not running asynchronously</h2>

<p>Here is another problematic code snippet from Lucian's slide. This time, the problem
is quite simple. The following snippet defines an asynchronous method <code>FooAsync</code> and
calls it from a <code>Handler</code>, but the code does not run asynchronously:</p>

<pre><code>async Task FooAsync() {
  await Task.Delay(1000);
}
void Handler() {
  FooAsync().Wait();
}
</code></pre>

<p>It is not too difficult to spot the issue - we are calling <code>FooAsync().Wait()</code>. This 
means that we create a task and then, using <code>Wait</code>, block until it completes. Simply
removing <code>Wait</code> fixes the problem, because we just want to start the task.</p>

<p>You can write the same code in F#, but asynchronous workflows do not use .NET Tasks
(which were originally designed for CPU-bound computations) and instead uses F#
<code>Async&lt;T&gt;</code> which does not come with <code>Wait</code>. This means you have to write:</p>
<pre class="fssnip">
<span class="l">1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 69)" onmouseover="showTip(event, 'fs27', 69)" class="i">fooAsync</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'fs5', 70)" onmouseover="showTip(event, 'fs5', 70)" class="i">async</span> {
<span class="l">2: </span>  <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs6', 71)" onmouseover="showTip(event, 'fs6', 71)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs7', 72)" onmouseover="showTip(event, 'fs7', 72)" class="i">Sleep</span>(<span class="n">1000</span>) }
<span class="l">3: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fs28', 73)" onmouseover="showTip(event, 'fs28', 73)" class="i">handler</span>() <span class="o">=</span> 
<span class="l">4: </span>  <span onmouseout="hideTip(event, 'fs27', 74)" onmouseover="showTip(event, 'fs27', 74)" class="i">fooAsync</span>() <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs6', 75)" onmouseover="showTip(event, 'fs6', 75)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs29', 76)" onmouseover="showTip(event, 'fs29', 76)" class="i">RunSynchronously</span></pre>
<p>You could certainly write such code by accident, but if you face a problem that it does
not run <em>asynchronously</em>, you can easily spot that the code calls
<code>RunSynchronously</code> and so the work is done - as the name suggests - <em>synchronously</em>.</p>

<h2>Summary</h2>

<p>In this article, I looked at six cases where the C# asynchronous programming model
behaves in an unexpected way. Most of them were based on a talk by Lucian and Stephen
at the MVP summit, so thanks to both of them for sharing an interesting list of common
pitfalls!</p>

<p>I tried to find the closest corresponding code snippet in F#, using asynchronous workflows.
In most of the cases, the F# compiler reports a warning or an error - or the programming
model does not have a (direct) way to express the same code. I think this supports the 
claim that I made <a href="http://tomasp.net/blog/csharp-fsharp-async-intro.aspx" title="Tomas Petricek: Asynchronous C# and F# (I.): Simultaneous introduction">in an earlier blog post</a> that <em>"The F# programming model definitely 
feels more suitable for functional (declarative) programming languages. I also think that it 
makes it easier to reason about what is going on"</em>.</p>

<p>Finally, this article should not be understood as a devastating criticism of C# async :-). I can 
fully understand why the C# design follows the principles it follows - for C#, it makes
sense to use <code>Task&lt;T&gt;</code> (instead of separate <code>Async&lt;T&gt;</code>), which has a number of implications.
And I can understand the reasoning behind other decisions too - it is likely the best way
to integrate asynchronous programming in C#. But at the same time, I think F# does a better 
job - partly because of the composability, but more importantly because of greate additions
like the <a href="http://www.developerfusion.com/article/139804/an-introduction-to-f-agents" title="Tomas Petricek: An Introduction To F# Agents">F# agents</a>. Also, F# async has its problems too (the most common gotcha
is that tail-recursive functions must use <code>return!</code> instead of <code>do!</code> to avoid leaks), but 
that is a topic for a separate blog post.</p>

<div class="tip" id="fs1">val workThenWait : unit -&gt; Async&lt;unit&gt;<br /><br />Full name: Csharp-async-gotchas_.workThenWait</div>
<div class="tip" id="fs2">Multiple items<br />type Thread =<br />&#160;&#160;inherit CriticalFinalizerObject<br />&#160;&#160;new : start:ThreadStart -&gt; Thread + 3 overloads<br />&#160;&#160;member Abort : unit -&gt; unit + 1 overload<br />&#160;&#160;member ApartmentState : ApartmentState with get, set<br />&#160;&#160;member CurrentCulture : CultureInfo with get, set<br />&#160;&#160;member CurrentUICulture : CultureInfo with get, set<br />&#160;&#160;member DisableComObjectEagerCleanup : unit -&gt; unit<br />&#160;&#160;member ExecutionContext : ExecutionContext<br />&#160;&#160;member GetApartmentState : unit -&gt; ApartmentState<br />&#160;&#160;member GetCompressedStack : unit -&gt; CompressedStack<br />&#160;&#160;member GetHashCode : unit -&gt; int<br />&#160;&#160;...<br /><br />Full name: System.Threading.Thread<br /><br />--------------------<br />Thread(start: ThreadStart) : unit<br />Thread(start: ParameterizedThreadStart) : unit<br />Thread(start: ThreadStart, maxStackSize: int) : unit<br />Thread(start: ParameterizedThreadStart, maxStackSize: int) : unit</div>
<div class="tip" id="fs3">Thread.Sleep(timeout: TimeSpan) : unit<br />Thread.Sleep(millisecondsTimeout: int) : unit</div>
<div class="tip" id="fs4">val printfn : format:Printf.TextWriterFormat&lt;&#39;T&gt; -&gt; &#39;T<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.printfn</div>
<div class="tip" id="fs5">val async : AsyncBuilder<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.async</div>
<div class="tip" id="fs6">Multiple items<br />type Async<br />static member AsBeginEnd : computation:(&#39;Arg -&gt; Async&lt;&#39;T&gt;) -&gt; (&#39;Arg * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt; &#39;T) * (IAsyncResult -&gt; unit)<br />static member AwaitEvent : event:IEvent&lt;&#39;Del,&#39;T&gt; * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt; (requires delegate and &#39;Del :&gt; Delegate)<br />static member AwaitIAsyncResult : iar:IAsyncResult * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />static member AwaitTask : task:Task&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt;<br />static member AwaitWaitHandle : waitHandle:WaitHandle * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />static member CancelDefaultToken : unit -&gt; unit<br />static member Catch : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;Choice&lt;&#39;T,exn&gt;&gt;<br />static member FromBeginEnd : beginAction:(AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg:&#39;Arg1 * beginAction:(&#39;Arg1 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * beginAction:(&#39;Arg1 * &#39;Arg2 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * arg3:&#39;Arg3 * beginAction:(&#39;Arg1 * &#39;Arg2 * &#39;Arg3 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromContinuations : callback:((&#39;T -&gt; unit) * (exn -&gt; unit) * (OperationCanceledException -&gt; unit) -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member Ignore : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;unit&gt;<br />static member OnCancel : interruption:(unit -&gt; unit) -&gt; Async&lt;IDisposable&gt;<br />static member Parallel : computations:seq&lt;Async&lt;&#39;T&gt;&gt; -&gt; Async&lt;&#39;T []&gt;<br />static member RunSynchronously : computation:Async&lt;&#39;T&gt; * ?timeout:int * ?cancellationToken:CancellationToken -&gt; &#39;T<br />static member Sleep : millisecondsDueTime:int -&gt; Async&lt;unit&gt;<br />static member Start : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit<br />static member StartAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:TaskCreationOptions * ?cancellationToken:CancellationToken -&gt; Task&lt;&#39;T&gt;<br />static member StartChild : computation:Async&lt;&#39;T&gt; * ?millisecondsTimeout:int -&gt; Async&lt;Async&lt;&#39;T&gt;&gt;<br />static member StartChildAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:TaskCreationOptions -&gt; Async&lt;Task&lt;&#39;T&gt;&gt;<br />static member StartImmediate : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit<br />static member StartWithContinuations : computation:Async&lt;&#39;T&gt; * continuation:(&#39;T -&gt; unit) * exceptionContinuation:(exn -&gt; unit) * cancellationContinuation:(OperationCanceledException -&gt; unit) * ?cancellationToken:CancellationToken -&gt; unit<br />static member SwitchToContext : syncContext:SynchronizationContext -&gt; Async&lt;unit&gt;<br />static member SwitchToNewThread : unit -&gt; Async&lt;unit&gt;<br />static member SwitchToThreadPool : unit -&gt; Async&lt;unit&gt;<br />static member TryCancelled : computation:Async&lt;&#39;T&gt; * compensation:(OperationCanceledException -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member CancellationToken : Async&lt;CancellationToken&gt;<br />static member DefaultCancellationToken : CancellationToken<br /><br />Full name: Microsoft.FSharp.Control.Async<br /><br />--------------------<br />type Async&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Control.Async&lt;_&gt;</div>
<div class="tip" id="fs7">static member Async.Sleep : millisecondsDueTime:int -&gt; Async&lt;unit&gt;</div>
<div class="tip" id="fs8">val demo : unit -&gt; unit<br /><br />Full name: Csharp-async-gotchas_.demo</div>
<div class="tip" id="fs9">val work : Task&lt;unit&gt;</div>
<div class="tip" id="fs10">static member Async.StartAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:TaskCreationOptions * ?cancellationToken:CancellationToken -&gt; Task&lt;&#39;T&gt;</div>
<div class="tip" id="fs11">Task.Wait() : unit<br />Task.Wait(millisecondsTimeout: int) : bool<br />Task.Wait(cancellationToken: CancellationToken) : unit<br />Task.Wait(timeout: TimeSpan) : bool<br />Task.Wait(millisecondsTimeout: int, cancellationToken: CancellationToken) : bool</div>
<div class="tip" id="fs12">val handler : unit -&gt; Async&lt;unit&gt;<br /><br />Full name: Csharp-async-gotchas_.handler</div>
<div class="tip" id="fs13">val throwExceptionAsync : unit -&gt; Async&lt;unit&gt;<br /><br />Full name: Csharp-async-gotchas_.throwExceptionAsync</div>
<div class="tip" id="fs14">val raise : exn:Exception -&gt; &#39;T<br /><br />Full name: Microsoft.FSharp.Core.Operators.raise</div>
<div class="tip" id="fs15">Multiple items<br />type InvalidOperationException =<br />&#160;&#160;inherit SystemException<br />&#160;&#160;new : unit -&gt; InvalidOperationException + 2 overloads<br /><br />Full name: System.InvalidOperationException<br /><br />--------------------<br />InvalidOperationException() : unit<br />InvalidOperationException(message: string) : unit<br />InvalidOperationException(message: string, innerException: exn) : unit</div>
<div class="tip" id="fs16">val callThrowExceptionAsync : unit -&gt; unit<br /><br />Full name: Csharp-async-gotchas_.callThrowExceptionAsync</div>
<div class="tip" id="fs17">static member Async.Start : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit</div>
<div class="tip" id="fs18">val e : exn</div>
<div class="tip" id="fs19">type Parallel =<br />&#160;&#160;static member For : fromInclusive:int * toExclusive:int * body:Action&lt;int&gt; -&gt; ParallelLoopResult + 11 overloads<br />&#160;&#160;static member ForEach&lt;&#39;TSource&gt; : source:IEnumerable&lt;&#39;TSource&gt; * body:Action&lt;&#39;TSource&gt; -&gt; ParallelLoopResult + 19 overloads<br />&#160;&#160;static member Invoke : params actions:Action[] -&gt; unit + 1 overload<br /><br />Full name: System.Threading.Tasks.Parallel</div>
<div class="tip" id="fs20">Parallel.For(fromInclusive: int64, toExclusive: int64, body: Action&lt;int64,ParallelLoopState&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />Parallel.For(fromInclusive: int, toExclusive: int, body: Action&lt;int,ParallelLoopState&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />Parallel.For(fromInclusive: int64, toExclusive: int64, body: Action&lt;int64&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />Parallel.For(fromInclusive: int, toExclusive: int, body: Action&lt;int&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />Parallel.For(fromInclusive: int64, toExclusive: int64, parallelOptions: ParallelOptions, body: Action&lt;int64,ParallelLoopState&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />Parallel.For(fromInclusive: int, toExclusive: int, parallelOptions: ParallelOptions, body: Action&lt;int,ParallelLoopState&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />Parallel.For(fromInclusive: int64, toExclusive: int64, parallelOptions: ParallelOptions, body: Action&lt;int64&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />Parallel.For(fromInclusive: int, toExclusive: int, parallelOptions: ParallelOptions, body: Action&lt;int&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />Parallel.For&lt;&#39;TLocal&gt;(fromInclusive: int64, toExclusive: int64, localInit: Func&lt;&#39;TLocal&gt;, body: Func&lt;int64,ParallelLoopState,&#39;TLocal,&#39;TLocal&gt;, localFinally: Action&lt;&#39;TLocal&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />Parallel.For&lt;&#39;TLocal&gt;(fromInclusive: int, toExclusive: int, localInit: Func&lt;&#39;TLocal&gt;, body: Func&lt;int,ParallelLoopState,&#39;TLocal,&#39;TLocal&gt;, localFinally: Action&lt;&#39;TLocal&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em></div>
<div class="tip" id="fs21">val i : &#39;a</div>
<div class="tip" id="fs22">val i : int</div>
<div class="tip" id="fs23">Multiple items<br />type Task =<br />&#160;&#160;new : action:Action -&gt; Task + 7 overloads<br />&#160;&#160;member AsyncState : obj<br />&#160;&#160;member ConfigureAwait : continueOnCapturedContext:bool -&gt; ConfiguredTaskAwaitable<br />&#160;&#160;member ContinueWith : continuationAction:Action&lt;Task&gt; -&gt; Task + 19 overloads<br />&#160;&#160;member CreationOptions : TaskCreationOptions<br />&#160;&#160;member Dispose : unit -&gt; unit<br />&#160;&#160;member Exception : AggregateException<br />&#160;&#160;member GetAwaiter : unit -&gt; TaskAwaiter<br />&#160;&#160;member Id : int<br />&#160;&#160;member IsCanceled : bool<br />&#160;&#160;...<br /><br />Full name: System.Threading.Tasks.Task<br /><br />--------------------<br />type Task&lt;&#39;TResult&gt; =<br />&#160;&#160;inherit Task<br />&#160;&#160;new : function:Func&lt;&#39;TResult&gt; -&gt; Task&lt;&#39;TResult&gt; + 7 overloads<br />&#160;&#160;member ConfigureAwait : continueOnCapturedContext:bool -&gt; ConfiguredTaskAwaitable&lt;&#39;TResult&gt;<br />&#160;&#160;member ContinueWith : continuationAction:Action&lt;Task&lt;&#39;TResult&gt;&gt; -&gt; Task + 19 overloads<br />&#160;&#160;member GetAwaiter : unit -&gt; TaskAwaiter&lt;&#39;TResult&gt;<br />&#160;&#160;member Result : &#39;TResult<br />&#160;&#160;static member Factory : TaskFactory&lt;&#39;TResult&gt;<br /><br />Full name: System.Threading.Tasks.Task&lt;_&gt;<br /><br />--------------------<br />Task(action: Action) : unit<br />Task(action: Action, cancellationToken: CancellationToken) : unit<br />Task(action: Action, creationOptions: TaskCreationOptions) : unit<br />Task(action: Action&lt;obj&gt;, state: obj) : unit<br />Task(action: Action, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions) : unit<br />Task(action: Action&lt;obj&gt;, state: obj, cancellationToken: CancellationToken) : unit<br />Task(action: Action&lt;obj&gt;, state: obj, creationOptions: TaskCreationOptions) : unit<br />Task(action: Action&lt;obj&gt;, state: obj, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions) : unit<br /><br />--------------------<br />Task(function: Func&lt;&#39;TResult&gt;) : unit<br />Task(function: Func&lt;&#39;TResult&gt;, cancellationToken: CancellationToken) : unit<br />Task(function: Func&lt;&#39;TResult&gt;, creationOptions: TaskCreationOptions) : unit<br />Task(function: Func&lt;obj,&#39;TResult&gt;, state: obj) : unit<br />Task(function: Func&lt;&#39;TResult&gt;, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions) : unit<br />Task(function: Func&lt;obj,&#39;TResult&gt;, state: obj, cancellationToken: CancellationToken) : unit<br />Task(function: Func&lt;obj,&#39;TResult&gt;, state: obj, creationOptions: TaskCreationOptions) : unit<br />Task(function: Func&lt;obj,&#39;TResult&gt;, state: obj, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions) : unit</div>
<div class="tip" id="fs24">Multiple items<br />property Task.Factory: TaskFactory<br /><br />--------------------<br />property Task.Factory: TaskFactory&lt;&#39;TResult&gt;</div>
<div class="tip" id="fs25">Multiple items<br />TaskFactory.StartNew&lt;&#39;TResult&gt;(function: Func&lt;&#39;TResult&gt;) : Task&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />TaskFactory.StartNew(action: Action) : Task<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />TaskFactory.StartNew&lt;&#39;TResult&gt;(function: Func&lt;obj,&#39;TResult&gt;, state: obj) : Task&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />TaskFactory.StartNew&lt;&#39;TResult&gt;(function: Func&lt;&#39;TResult&gt;, creationOptions: TaskCreationOptions) : Task&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />TaskFactory.StartNew&lt;&#39;TResult&gt;(function: Func&lt;&#39;TResult&gt;, cancellationToken: CancellationToken) : Task&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />TaskFactory.StartNew(action: Action&lt;obj&gt;, state: obj) : Task<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />TaskFactory.StartNew(action: Action, creationOptions: TaskCreationOptions) : Task<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />TaskFactory.StartNew(action: Action, cancellationToken: CancellationToken) : Task<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />TaskFactory.StartNew&lt;&#39;TResult&gt;(function: Func&lt;obj,&#39;TResult&gt;, state: obj, creationOptions: TaskCreationOptions) : Task&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />TaskFactory.StartNew&lt;&#39;TResult&gt;(function: Func&lt;obj,&#39;TResult&gt;, state: obj, cancellationToken: CancellationToken) : Task&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br /><br />--------------------<br />TaskFactory.StartNew(function: Func&lt;&#39;TResult&gt;) : Task&lt;&#39;TResult&gt;<br />TaskFactory.StartNew(function: Func&lt;obj,&#39;TResult&gt;, state: obj) : Task&lt;&#39;TResult&gt;<br />TaskFactory.StartNew(function: Func&lt;&#39;TResult&gt;, creationOptions: TaskCreationOptions) : Task&lt;&#39;TResult&gt;<br />TaskFactory.StartNew(function: Func&lt;&#39;TResult&gt;, cancellationToken: CancellationToken) : Task&lt;&#39;TResult&gt;<br />TaskFactory.StartNew(function: Func&lt;obj,&#39;TResult&gt;, state: obj, creationOptions: TaskCreationOptions) : Task&lt;&#39;TResult&gt;<br />TaskFactory.StartNew(function: Func&lt;obj,&#39;TResult&gt;, state: obj, cancellationToken: CancellationToken) : Task&lt;&#39;TResult&gt;<br />TaskFactory.StartNew(function: Func&lt;&#39;TResult&gt;, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler) : Task&lt;&#39;TResult&gt;<br />TaskFactory.StartNew(function: Func&lt;obj,&#39;TResult&gt;, state: obj, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler) : Task&lt;&#39;TResult&gt;</div>
<div class="tip" id="fs26">static member Async.AwaitTask : task:Task&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt;</div>
<div class="tip" id="fs27">val fooAsync : unit -&gt; Async&lt;unit&gt;<br /><br />Full name: Csharp-async-gotchas_.fooAsync</div>
<div class="tip" id="fs28">val handler : unit -&gt; unit<br /><br />Full name: Csharp-async-gotchas_.handler</div>
<div class="tip" id="fs29">static member Async.RunSynchronously : computation:Async&lt;&#39;T&gt; * ?timeout:int * ?cancellationToken:CancellationToken -&gt; &#39;T</div>

    </content>

  </div>
	<div class="large-4 columns">
    <div style="background:black; text-align:center;padding:20px;">
      <img src="http://tomasp.net/calendar/2013/august_sm.jpg" />
    </div>

		<h4>Right panel</h4>
	</div>
</div>

  </content>

  <footer>
    tomas
  </footer>

  <script>
  document.write('<script src=' +
  ('__proto__' in {} ? 'js/vendor/zepto' : 'js/vendor/jquery') +
  '.js><\/script>')
  </script>
  
  <script src="js/foundation.min.js"></script>
  <!--
  
  <script src="js/foundation/foundation.js"></script>
  
  <script src="js/foundation/foundation.alerts.js"></script>
  
  <script src="js/foundation/foundation.clearing.js"></script>
  
  <script src="js/foundation/foundation.cookie.js"></script>
  
  <script src="js/foundation/foundation.dropdown.js"></script>
  
  <script src="js/foundation/foundation.forms.js"></script>
  
  <script src="js/foundation/foundation.joyride.js"></script>
  
  <script src="js/foundation/foundation.magellan.js"></script>
  
  <script src="js/foundation/foundation.orbit.js"></script>
  
  <script src="js/foundation/foundation.reveal.js"></script>
  
  <script src="js/foundation/foundation.section.js"></script>
  
  <script src="js/foundation/foundation.tooltips.js"></script>
  
  <script src="js/foundation/foundation.topbar.js"></script>
  
  <script src="js/foundation/foundation.interchange.js"></script>
  
  <script src="js/foundation/foundation.placeholder.js"></script>
  
  <script src="js/foundation/foundation.abide.js"></script>
  
  -->
  
  <script>
    $(document).foundation();
  </script>
</body>
</html>